/*
 * This file is part of eyeo's Web Extension Ad Blocking Toolkit (EWE),
 * Copyright (C) 2006-present eyeo GmbH
 *
 * EWE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * EWE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with EWE.  If not, see <http://www.gnu.org/licenses/>.
 */

import browser from "webextension-polyfill";
import {
    ignoreNoConnectionError
} from "../errors.js";

let collapsedSelectors = new Set();
let observers = new WeakMap();

function getURLFromElement(element) {
    if (element.localName == "object") {
        if (element.data)
            return element.data;

        for (let child of element.children) {
            if (child.localName == "param" && child.name == "movie" && child.value)
                return new URL(child.value, document.baseURI).href;
        }

        return null;
    }

    return element.currentSrc || element.src;
}

function getSelectorForBlockedElement(element) {
    // Setting the "display" CSS property to "none" doesn't have any effect on
    // <frame> elements (in framesets). So we have to hide it inline through
    // the "visibility" CSS property.
    if (element.localName == "frame")
        return null;

    // If the <video> or <audio> element contains any <source> children,
    // we cannot address it in CSS by the source URL; in that case we
    // don't "collapse" it using a CSS selector but rather hide it directly by
    // setting the style="..." attribute.
    if (element.localName == "video" || element.localName == "audio") {
        for (let child of element.children) {
            if (child.localName == "source")
                return null;
        }
    }

    let selector = "";
    for (let attr of ["src", "srcset"]) {
        let value = element.getAttribute(attr);
        if (value && attr in element)
            selector += "[" + attr + "=" + CSS.escape(value) + "]";
    }

    return selector ? element.localName + selector : null;
}

export function hideElement(element, properties) {
    let {
        style
    } = element;

    if (!properties) {
        if (element.localName == "frame")
            properties = [
                ["visibility", "hidden"]
            ];
        else
            properties = [
                ["display", "none"]
            ];
    }

    for (let [key, value] of properties)
        style.setProperty(key, value, "important");

    if (observers.has(element))
        observers.get(element).disconnect();

    let observer = new MutationObserver(() => {
        for (let [key, value] of properties) {
            if (style.getPropertyValue(key) != value ||
                style.getPropertyPriority(key) != "important")
                style.setProperty(key, value, "important");
        }
    });
    observer.observe(
        element, {
            attributes: true,
            attributeFilter: ["style"]
        }
    );
    observers.set(element, observer);
}

export function unhideElement(element) {
    let observer = observers.get(element);
    if (observer) {
        observer.disconnect();
        observers.delete(element);
    }

    let property = element.localName == "frame" ? "visibility" : "display";
    element.style.removeProperty(property);
}

function collapseElement(element) {
    let selector = getSelectorForBlockedElement(element);
    if (!selector) {
        hideElement(element);
        return;
    }

    if (!collapsedSelectors.has(selector)) {
        ignoreNoConnectionError(
            browser.runtime.sendMessage({
                type: "ewe:inject-css",
                selector
            })
        );
        collapsedSelectors.add(selector);
    }
}

function hideInAboutBlankFrames(selector, urls) {
    // Resources (e.g. images) loaded into about:blank frames
    // are (sometimes) loaded with the frameId of the main_frame.
    for (let frame of document.querySelectorAll("iframe[src='about:blank']")) {
        if (!frame.contentDocument)
            continue;

        for (let element of frame.contentDocument.querySelectorAll(selector)) {
            // Use hideElement, because we don't have the correct frameId
            // for the "ewe:inject-css" message.
            if (urls.has(getURLFromElement(element)))
                hideElement(element);
        }
    }
}

export function startElementCollapsing() {
    let deferred = null;

    browser.runtime.onMessage.addListener((message, sender) => {
        if (!message || message.type != "ewe:collapse")
            return false;

        if (document.readyState == "loading") {
            if (!deferred) {
                deferred = new Map();
                document.addEventListener("DOMContentLoaded", () => {
                    for (let [selector, urls] of deferred) {
                        for (let element of document.querySelectorAll(selector)) {
                            if (urls.has(getURLFromElement(element)))
                                collapseElement(element);
                        }

                        hideInAboutBlankFrames(selector, urls);
                    }

                    deferred = null;
                });
            }

            let urls = deferred.get(message.selector) || new Set();
            deferred.set(message.selector, urls);
            urls.add(message.url);
        } else {
            for (let element of document.querySelectorAll(message.selector)) {
                if (getURLFromElement(element) == message.url)
                    collapseElement(element);
            }

            hideInAboutBlankFrames(message.selector, new Set([message.url]));
        }
        return true;
    });
}